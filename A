local serverURL = "https://aca81e58-d6f7-45fa-b644-30bbaad780a5-00-3oqlxf9wb5ogo.picard.replit.dev"

local tool = Instance.new("Tool")
tool.Name = "Bloqueador"
tool.RequiresHandle = false
tool.Parent = game.Players.LocalPlayer.Backpack

local HttpService = game:GetService("HttpService")
local player = game.Players.LocalPlayer

-- Tabla para almacenar posiciones de bloques ya creados localmente (keys string "x_y_z")
local bloquesLocales = {}

local function posToKey(pos)
    -- Convierto Vector3 a string para indexar
    return string.format("%.2f_%.2f_%.2f", pos.X, pos.Y, pos.Z)
end

local function hayBloqueEnPos(pos)
    local key = posToKey(pos)
    return bloquesLocales[key] ~= nil
end

local function colocarBloque(pos)
    local key = posToKey(pos)
    if bloquesLocales[key] then return end

    local bloque = Instance.new("Part")
    bloque.Size = Vector3.new(4, 4, 4)
    bloque.Anchored = true
    bloque.CanCollide = true
    bloque.Position = pos
    bloque.Color = Color3.fromRGB(255, 255, 0)
    bloque.Parent = workspace

    bloquesLocales[key] = bloque
end

local function enviarBloque(pos)
    local body = HttpService:JSONEncode({
        x = pos.X,
        y = pos.Y,
        z = pos.Z,
        color = "amarillo"
    })

    local success, response = pcall(function()
        return syn.request({
            Url = serverURL.."/colocar",
            Method = "POST",
            Headers = {["Content-Type"] = "application/json"},
            Body = body
        })
    end)

    if not success then
        warn("Error al enviar bloque:", response)
    end
end

tool.Activated:Connect(function()
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local posJugador = hrp.Position
    local posBloque = posJugador -- enviar sin redondear, el servidor lo hace

    colocarBloque(posBloque)
    enviarBloque(posBloque)
end)

task.spawn(function()
    while true do
        local success, res = pcall(function()
            return syn.request({
                Url = serverURL.."/bloques",
                Method = "GET"
            })
        end)

        if success and res.StatusCode == 200 then
            local ok, lista = pcall(function()
                return HttpService:JSONDecode(res.Body)
            end)

            if ok and type(lista) == "table" then
                for _, b in ipairs(lista) do
                    local pos = Vector3.new(b.x, b.y, b.z)
                    if not hayBloqueEnPos(pos) then
                        colocarBloque(pos)
                    end
                end
            else
                warn("Error al decodificar la lista de bloques")
            end
        else
            warn("Error al obtener bloques del servidor")
        end

        task.wait(3)
    end
end)        color = "amarillo"
    })

    syn.request({
        Url = serverURL.."/colocar",
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = body
    })
end

-- Cuando activas el Tool
tool.Activated:Connect(function()
    local posJugador = player.Character.HumanoidRootPart.Position
    local posBloque = Vector3.new(
        math.floor(posJugador.X / 4 + 0.5) * 4,
        math.floor(posJugador.Y / 4 + 0.5) * 4,
        math.floor(posJugador.Z / 4 + 0.5) * 4
    )
    colocarBloque(posBloque)
    enviarBloque(posBloque)
end)

-- Actualizar bloques de otros jugadores
task.spawn(function()
    while true do
        local res = syn.request({
            Url = serverURL.."/bloques",
            Method = "GET"
        })
        local lista = HttpService:JSONDecode(res.Body)
        for _, b in ipairs(lista) do
            colocarBloque(Vector3.new(b.x, b.y, b.z))
        end
        task.wait(2) -- Actualizar cada 2 segundos
    end
end)
